//! Used to generate C# wrapper code for a Rust WebAssembly module translated to a .NET assembly by `wacil`.

use std::fmt::{Display, Formatter};
use std::io::Write;
use wacil_bindgen::interface::{self, types};

type Result = std::io::Result<()>;

enum Expression<'a> {
    NewInstance(&'a types::Type, &'a [Expression<'a>]),
}

impl Display for Expression<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        use std::fmt::Write;
        match self {
            Self::NewInstance(ty, arguments) => {
                write!(f, "new {}(", ty)?;
                arguments.iter().enumerate().try_for_each(|(index, arg)| {
                    if index > 0 {
                        f.write_str(", ")?;
                    }
                    Display::fmt(arg, f)
                })?;
                f.write_char(')')
            }
        }
    }
}

struct Destination<W: Write> {
    out: W,
    is_new_line: bool,
}

impl<W: Write> Destination<W> {
    fn new(destination: W) -> Self {
        Self {
            out: destination,
            is_new_line: true,
        }
    }

    fn require_new_line(&mut self) -> Result {
        if !self.is_new_line {
            writeln!(self.out)?;
            self.is_new_line = true;
        }

        Ok(())
    }

    fn write_fmt(&mut self, args: core::fmt::Arguments<'_>) -> Result {
        self.is_new_line = false;
        self.out.write_fmt(args)
    }

    fn write(&mut self, s: &str) -> Result {
        if !s.is_empty() {
            self.is_new_line = false;
            self.out.write_all(s.as_bytes())?;
        }
        Ok(())
    }

    fn write_display(&mut self, d: impl Display) -> Result {
        self.write_fmt(format_args!("{d}"))
    }

    fn write_comment(&mut self, contents: &str) -> Result {
        self.require_new_line()?;
        self.write("// ")?;
        self.write(contents)
    }

    fn write_region<F: FnOnce(&mut Self) -> Result>(&mut self, name: &str, contents: F) -> Result {
        self.require_new_line()?;
        self.write("#region ")?;
        self.write(name)?;
        self.require_new_line()?;
        contents(self)?;
        self.require_new_line()?;
        self.write("#endregion")
    }

    fn write_namespace<F: FnOnce(&mut Self) -> Result>(&mut self, namespace: interface::Namespace, contents: F) -> Result {
        if !namespace.names().is_empty() {
            self.require_new_line()?;
            self.write("namespace ")?;
            self.write_fmt(format_args!("{namespace}"))?;
            self.write(" {")?;
            self.require_new_line()?;
            contents(self)?;
            self.require_new_line()?;
            self.write("}")
        } else {
            contents(self)
        }
    }

    fn write_modifiers(&mut self, modifiers: &[&str]) -> Result {
        modifiers.iter().try_for_each(|word| self.write_fmt(format_args!("{word} ")))
    }

    fn write_class<F: FnOnce(&mut Self) -> Result>(&mut self, name: interface::Name, modifiers: &[&'static str], contents: F) -> Result {
        self.require_new_line()?;
        self.write_modifiers(modifiers)?;
        self.write("class ")?;
        self.write(name)?;
        self.write(" {")?;
        self.require_new_line()?;
        contents(self)?;
        self.require_new_line()?;
        self.write("}")
    }

    fn write_field(
        &mut self,
        name: interface::Name,
        modifiers: &[&'static str],
        ty: &types::Type,
        expression: Option<&Expression<'_>>,
    ) -> Result {
        self.require_new_line()?;
        self.write_modifiers(modifiers)?;
        self.write_display(ty)?;
        self.write(" ")?;
        self.write(name)?;
        if let Some(value) = expression {
            self.write(" = ")?;
            self.write_display(value)?;
        }
        self.write(";")
    }
}

pub struct Module {
    pub interfaces: &'static [&'static interface::Interface],
    pub module_name: interface::TypeName,
    pub wrapper_name: interface::TypeName,
}

pub fn generate<W: Write>(module: &Module, destination: W) -> Result {
    let mut out = Destination::new(destination);
    out.write_comment("<auto-generated>Generated by wacil</auto-generated>")?;
    out.write_namespace(module.wrapper_name.namespace, |out| {
        out.write_class(module.wrapper_name.name, &["public", "sealed"], |out| {
            out.write_field(
                "locker",
                &["readonly"],
                &types::Type::Object,
                Some(&Expression::NewInstance(&types::Type::Object, &[])),
            )?;

            let module_type = types::Type::Named {
                name: module.module_name,
                arguments: &[],
            };

            out.write_field("module", &["readonly"], &module_type, None)?;

            Ok(())
        })
    })?;
    out.require_new_line()
}
